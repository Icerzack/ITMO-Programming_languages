extern read_word						;Импортируем функцию read_word из lib.asm
extern print_newline						;Импортируем функцию print_newline из lib.asm
extern print_string						;Импортируем функцию print_string из lib.asm
extern string_length						;Импортируем функцию string_length из lib.asm
extern find_word						;Импортируем функцию find_word из dict.asm
extern print_error						;Импортируем функцию print_error из lib.asm
extern exit							;Импортируем функцию exit из lib.asm



global _start							;Указываем глоблальную метку 


section .rodata							;Секция с константными данными

not_found: db "Ничего не найдено по такому ключу =(", 0		;Сообщение об ошибке, что не найдено соответствие
not_enough: db 'Введенная строка больше чем 255 символов', 0	;Сообщение об ошибке, что введенная строка слишком большая


section .data							;Секция с обычными (изменяемыми в нашем случае) данными

buffer: times 256 db 0						;Храним здесь введеную строку


section .text							;Начало секции с кодом

%include "colon.inc"						;Подключаем colon.inc
%include "words.inc"						;Подключаем words.inc


_start:								;Метка начала программы
    mov rdi, buffer						;Передаем в rdi наш указатель адрес начала буфера
    mov rsi, 255						;Передаем в rsi максимально возможный размер для ввода
    call read_word						;Считываем введенное слово
    test rax, rax						;Слово оказалось больше буфера, rax == 0?
    je .not_enough						;Если так, то завершаем программу ошибкой "Мало места"
    mov rdi, rax						;Кладем в rdi сам введенный ключ поиска
    mov rsi, next						;Иначе же кладем в rsi адрес начала нашего словаря (то есть последнего добавленого элемента)
    call find_word						;Вызываем find_word чтобы найти такой ключ в словаре
    test rax, rax						;Ничего не нашлось, rax == 0?
    je .not_found						;Если так, то завершаем программу ошибкой "Ключ не найден"
    add rax, 8							;Иначе же переходим на значение КЛЮЧА(а нам вернулся адрес НАЧАЛА ВХОЖДЕНИЯ в словарь (не значения), dq = 8 байт потому что).
    mov rdi, rax						;Кладем в rdi наш ключ
    push rax							;Сохраняем на стеке данный найденный ключ
    call string_length						;Смотрим на длину нашей строки (то есть ключа)
    pop rdi							;Снимаем в rdi наш сохраненный ранее ключ
    add rdi, rax						;!!! Добавляем к адресу НАЧАЛА КЛЮЧА вычисленную длину самого ключа, чтобы перейти на адрес нуль-терминатора этого ключа, то есть в конец (мы ведь не знаем длину ключа, поэтому "извращаемся" таким образом, чтобы получить значение по ключу)
    inc rdi							;Увеличиваем rdi на 1, чтобы получить адрес ЗНАЧЕНИЯ по нашему ключу
    call print_string						;Выводим данное значение по введенному ключу
    jmp .end							;И завершаем программу

.not_enough:							;Метка для кода с ошибкой "Мало места"
    mov rdi, not_enough						;В rdi кладем строку с ошибкой
    call print_error						;Вызываем из lib.asm функцию print_error чтобы вывести в поток ошибок
    jmp .end							;И завершаем программу

.not_found:							;Метка для кода с выводом ошибки "Ключ не найден"
    mov rdi, not_found						;Кладем rdi в строку с ошибкой
    call print_error						;Вызываем из lib.asm функцию print_error чтобы вывести в поток ошибок

.end:							;Метка завершения программы
    call print_newline						;Делаем перенос строки, чтобы вывод был читабелен
    call exit							;И завершаем исполнение программы
